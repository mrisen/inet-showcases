<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<analysis version="2">
    <inputs>
        <input pattern="results/NonQos-#0.vec"/>
        <input pattern="results/NonQos-#0.sca"/>
        <input pattern="results/Qos-#0.vec"/>
        <input pattern="results/Qos-#0.sca"/>
    </inputs>
    <charts>
        <chart name="End-to-end delay, realistic bitrate qos" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = chart.getProperties()&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;chart.plotVectors(df)&#10;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;# chart.setProperty('Line.Title/Qos-Throughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;" type="LineChart">
            <property name="Graph.Title" value="End-to-end delay, realistic bitrate qos"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="End-to-end delay [s]"/>
            <property name="X.Axis.Min" value="0.5"/>
            <property name="Line.Name/QosThroughput.server.app[0]" value="background"/>
            <property name="Line.Name/QosThroughput.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosThroughput.server.app[2]" value="video"/>
            <property name="Line.Name/QosThroughput.server.app[3]" value="voice"/>
            <property name="Line.Name/QosShowcase.server.app[0]" value="background"/>
            <property name="Line.Name/QosShowcase.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosShowcase.server.app[2]" value="video"/>
            <property name="Line.Name/QosShowcase.server.app[3]" value="voice"/>
        </chart>
        <chart name="Instantaneous packet delay variation, realistic bitrate qos" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*RealisticBitrate*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*RealisticBitrate*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*RealisticBitrate*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*RealisticBitrate*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = chart.getProperties()&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;for i in range(0,df.result['vecvalue'].shape[0]):&#10;    vals = df.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df.result['vecvalue'][i] = difference&#10;&#10;chart.plotVectors(df)&#10;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;&#10;print(chart.getProperties())" type="LineChart">
            <property name="Graph.Title" value="Instantaneous packet delay variation, realistic bitrate qos"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="Instantaneous packet delay variation [s]"/>
            <property name="Y.Axis.Min" value="-0.25"/>
            <property name="Y.Axis.Max" value="0.25"/>
            <property name="X.Axis.Min" value="0.5"/>
            <property name="Line.Name/QosThroughput.server.app[0]" value="background"/>
            <property name="Line.Name/QosThroughput.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosThroughput.server.app[2]" value="video"/>
            <property name="Line.Name/QosThroughput.server.app[3]" value="voice"/>
            <property name="Line.Name/QosShowcase.server.app[0]" value="background"/>
            <property name="Line.Name/QosShowcase.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosShowcase.server.app[2]" value="video"/>
            <property name="Line.Name/QosShowcase.server.app[3]" value="voice"/>
        </chart>
        <chart name="Throughput, realistic bitrate qos" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[3]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[0]) AND name(throughput:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;# print(df.result['vecvalue'])&#10;&#10;df.result['vecvalue'] /= 1000000&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;&#10;props = chart.getProperties()&#10;&#10;# print(&quot;props&quot;)&#10;# print(props)&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# print(&quot;names&quot;)&#10;# print(names)&#10;&#10;df[('attr','title')] = names&#10;&#10;chart.plotVectors(df)&#10;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput, realistic bitrate qos"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="Throughput [Mbps]"/>
            <property name="X.Axis.Min" value="0.5"/>
            <property name="X.Axis.Max" value="8.0"/>
            <property name="Line.Name/QosThroughput.server.app[0]" value="background"/>
            <property name="Line.Name/QosThroughput.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosThroughput.server.app[2]" value="video"/>
            <property name="Line.Name/QosThroughput.server.app[3]" value="voice"/>
            <property name="Line.Name/QosShowcase.server.app[0]" value="background"/>
            <property name="Line.Name/QosShowcase.server.app[1]" value="best effort"/>
            <property name="Line.Name/QosShowcase.server.app[2]" value="video"/>
            <property name="Line.Name/QosShowcase.server.app[3]" value="voice"/>
            <property name="Symbols.Type/QosShowcase.server.app[0]" value="Square"/>
            <property name="Line.Color/QosShowcase.server.app[0]" value="darkblue"/>
            <property name="Symbols.Type/QosShowcase.server.app[1]" value="Dot"/>
            <property name="Line.Color/QosShowcase.server.app[1]" value="red"/>
            <property name="Symbols.Type/QosShowcase.server.app[2]" value="Triangle"/>
            <property name="Line.Color/QosShowcase.server.app[2]" value="darkgreen"/>
            <property name="Symbols.Type/QosShowcase.server.app[3]" value="Diamond"/>
            <property name="Line.Color/QosShowcase.server.app[3]" value="orange"/>
        </chart>
        <chart name="End-to-end delay, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;&#10;plt.ylim(ymin, 2)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('End-to-end delay [s]')&#10;plt.title('End-to-end delay, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('delay_qos.png', dpi=150, transparent=True)" type="MatplotlibChart"/>
        <chart name="Instantaneous packet delay variation, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;for i in range(0,df.result['vecvalue'].shape[0]):&#10;    vals = df.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df.result['vecvalue'][i] = difference&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend(loc=1)&#10;plt.tight_layout(1.5)&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;#plt.ylim(-0.25, 0.25)&#10;plt.ylim(-0.02, 0.02)&#10;&#10;#----------------------------------------------------------------------------&#10;&#10;ax = plt.gca()&#10;&#10;# zoom level change event handling&#10;def on_xlims_change(axes):&#10;    print(&quot;plt.xlim&quot; + str(ax.get_xlim()))&#10;    solid_at_zero()&#10;&#10;def on_ylims_change(axes):&#10;    print(&quot;plt.ylim&quot; + str(ax.get_ylim()))&#10;    solid_at_zero()&#10;    &#10;ax.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax.callbacks.connect('ylim_changed', on_ylims_change)&#10;&#10;# set xlim/ylim here to get a specific zoom level image&#10;#plt.xlim(1, 1.84)&#10;#plt.ylim(-0.0023, 0.0038)&#10;#plt.tight_layout(2.5)&#10;&#10;left, right = plt.xlim()&#10;bottom, top = plt.ylim()&#10;&#10;# uncomment when zoomed&#10;#plt.ylim(bottom,top*1.1)&#10;&#10;print(left)&#10;print(right)&#10;print(bottom)&#10;print(top)&#10;&#10;#----------------------------------------------------------------------------&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;    # solid line at y=0&#10;def solid_at_zero():&#10;    a = ax.get_ygridlines()&#10;    &#10;    j = 0&#10;    r = 0&#10;    # TODO set everything to default here&#10;    for i in ticklocs:&#10;        if i == 0.0:&#10;            #print(&quot;found 0 at &quot;,j)&#10;            r = j&#10;            b = a[r]&#10;            b.set_color('black')&#10;            b.set_linestyle('solid')&#10;        j += 1&#10;    &#10;solid_at_zero()&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Instantaneous packet delay variation [s]')&#10;plt.title('Instantaneous packet delay variation, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('jitter_qos.png', dpi=150, transparent=True)&#10;#plt.savefig('jitter_qos_zoomed.png', dpi=150, transparent=True)&#10;&#10;" type="MatplotlibChart"/>
        <chart name="Throughput, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(throughput:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;    &#10;df.result['vecvalue'] /= 1000000&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=1, marker='s', markersize=1, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(0,6)&#10;plt.xlim(0.5,8)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Application-level throughput [Mbps]')&#10;plt.title('Throughput, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('throughput_qos.png', dpi=150, transparent=True)" type="MatplotlibChart"/>
        <chart name="End-to-end delay, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(0, 0.2)&#10;plt.xlim(0.5,xmax)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('End-to-end delay [s]')&#10;plt.title('End-to-end delay, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('delay_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Instantaneous packet delay variation, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;for i in range(0,df.result['vecvalue'].shape[0]):&#10;    vals = df.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df.result['vecvalue'][i] = difference&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;xmin, xmax = plt.xlim()&#10;&#10;#plt.ylim(-0.05, 0.05)&#10;plt.ylim(-0.15, 0.15)&#10;plt.xlim(0.5,xmax)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;ax = plt.gca()&#10;&#10;a = ax.get_ygridlines()&#10;&#10;b = a[3]&#10;b.set_color('black')&#10;b.set_linestyle('solid')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Instantaneous packet delay variation [s]')&#10;plt.title('Instantaneous packet delay variation, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('jitter_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Throughput, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import pandas as pd&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(throughput:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;#print(&quot;DF:&quot;,df[['attrname','attrvalue']])&#10;df2 = pd.DataFrame(df, columns=['attrname','attrvalue'])&#10;#print(&quot;DF_:&quot;,df2)&#10;#print(&quot;packetname:&quot;,df2.filter(like='packetName'))&#10;&#10;#df2.str.contains('packetName')&#10;&#10;df3 = df2[df2.attrname.str.contains('packetName',na=False)]&#10;&#10;#print(&quot;contains:&quot;, df3)&#10;&#10;#df3.attrvalue.str.replace('&quot;','')&#10;&#10;#print(&quot;df3 replaced:&quot;,df3)&#10;&#10;df4 = list(df3.attrvalue)&#10;&#10;names2 = []&#10;&#10;for i in df4:&#10;    i = i.replace('&quot;','')&#10;    print(&quot;i:&quot;,i)&#10;    print(&quot;type:&quot;,type(i))&#10;    names2.append(i)&#10;    #print(&quot;names2&quot;,names2)&#10;&#10;print(&quot;just the names:&quot;, names2)&#10;&#10;#print(&quot;XX:&quot;,df.index.get_level_values('attrname'))&#10;&#10;df = results.transform_results(df)&#10;    &#10;df.result['vecvalue'] /= 1000000&#10;&#10;df[('attr','title')] = names2&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=1, marker='s', markersize=1, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(-0.1,6)&#10;plt.xlim(0.5,8)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Application-level throughput [Mbps]')&#10;plt.title('Throughput, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('throughput_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
    </charts>
</analysis>
